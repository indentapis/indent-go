// Package plugin generates *.zap.go files containing zap marshalers.
package plugin

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"

	"go.indent.com/indent-go/api/indent/log"
)

type generator struct {
	*protogen.GeneratedFile
	conservative bool

	zapObjectMarshaler     protogen.GoIdent
	zapObjectEncoder       protogen.GoIdent
	zapArrayMarshalerFunc  protogen.GoIdent
	zapObjectMarshalerFunc protogen.GoIdent
	zapArrayEncoder        protogen.GoIdent

	fmtErrorf protogen.GoIdent
	fmtSprint protogen.GoIdent

	// tabs track the indentation level in the ouptut file.
	tabs int
}

// In increments g's indentation.
func (g *generator) In() {
	g.tabs++
}

// Out decrements g's indentation.
func (g *generator) Out() {
	g.tabs--
}

// P wraps g.GeneratedFile.P to include g.tabs.
func (g *generator) P(v ...interface{}) {
	g.GeneratedFile.P(append([]interface{}{strings.Repeat("\t", g.tabs)}, v...)...)
}

func newGenerator(
	gen *protogen.Plugin,
	file *protogen.File,
	conservative bool,
) *generator {
	filename := fmt.Sprintf("%s.zap.go", file.GeneratedFilenamePrefix)

	g := &generator{
		GeneratedFile: gen.NewGeneratedFile(filename, file.GoImportPath),
		conservative:  conservative,
	}

	zapcore := protogen.GoImportPath("go.uber.org/zap/zapcore")
	g.zapObjectMarshaler = zapcore.Ident("ObjectMarshaler")
	g.zapObjectEncoder = zapcore.Ident("ObjectEncoder")
	g.zapArrayMarshalerFunc = zapcore.Ident("ArrayMarshalerFunc")
	g.zapObjectMarshalerFunc = zapcore.Ident("ObjectMarshalerFunc")
	g.zapArrayEncoder = zapcore.Ident("ArrayEncoder")

	fmtpkg := protogen.GoImportPath("fmt")
	g.fmtErrorf = fmtpkg.Ident("Errorf")
	g.fmtSprint = fmtpkg.Ident("Sprint")

	// Generate preamble.
	g.P("// Code generated by protoc-gen-zap-marshaler. DO NOT EDIT.")
	if g.conservative {
		g.P("// Generated conservatively: no ObjectMarshaler implementations for messages")
		g.P("// without any logged fields.")
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.Import("go.uber.org/zap/zapcore")

	return g
}

//nolint:funlen // Many statements of low complexity.
func (g *generator) generateForMessage(msg *protogen.Message) {
	if msg.Desc.IsMapEntry() {
		return
	}

	// Add nested messages to g's tasks.
	// g.messages = append(g.messages, msg.Messages...)

	targets := make([]*protogen.Field, 0, len(msg.Fields))
	for _, field := range msg.Fields {
		if isTarget(field.Desc.Options()) {
			targets = append(targets, field)
		}
	}

	// Only define a MarshalLogObject method if it'll include at least one field.
	if len(targets) == 0 && g.conservative {
		return
	}

	g.P(`func (m *`, msg.GoIdent.GoName, `) MarshalLogObject(oe `, g.zapObjectEncoder, `) error {`)
	g.In()
	g.P(`var keyName string`)
	g.P(`_ = keyName`)
	g.P()
	g.P(`if m == nil {`)
	g.In()
	g.P(`return nil`)
	g.Out()
	g.P(`}`)
	g.P()

	for _, field := range targets {
		fieldName := field.GoName
		jsonName := field.Desc.JSONName()
		varName := fmt.Sprintf("m.%s", fieldName)
		g.P(`keyName = "`, fieldName, `" // field `, jsonName, ` = `, fmt.Sprint(field.Desc.Number()))

		repeated := field.Desc.Cardinality() == protoreflect.Repeated && !field.Desc.IsMap()
		if repeated {
			g.P(`oe.AddArray(keyName, `, g.zapArrayMarshalerFunc, `(func(ae `, g.zapArrayEncoder, `) error {`)
			g.In()
			g.P(`for _, rv := range `, varName, `{`)
			varName = "rv"
			g.In()
		}

		oneof, isOneof := getOneOf(field)
		if isOneof {
			g.P(`if val, ok := m.Get`, oneof.GoName, `().(*`, field.GoIdent, `); ok {`)
			g.In()
			varName = fmt.Sprintf("val.%s", fieldName)
		}

		g.generateForField(field, "keyName", varName, repeated)

		if isOneof {
			g.Out()
			g.P("}")
		}

		if repeated {
			g.Out()
			g.P(`}`)
			g.P(`return nil`)
			g.Out()
			g.P(`}))`)
		}

		g.P()
	}

	g.P(`return nil`)
	g.Out()
	g.P(`}`)
	g.P()

	// Recurse to cover nested messages.
	for _, nestedMessage := range msg.Messages {
		g.generateForMessage(nestedMessage)
	}
}

func (g *generator) generateForField(
	field *protogen.Field,
	keyName, varName string,
	repeated bool,
) {
	// Handle basic kinds.
	switch field.Desc.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		g.generateAdder("Int32", keyName, varName, repeated)
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.generateAdder("Int64", keyName, varName, repeated)
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		g.generateAdder("Uint32", keyName, varName, repeated)
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.generateAdder("Uint64", keyName, varName, repeated)
	case protoreflect.FloatKind:
		g.generateAdder("Float32", keyName, varName, repeated)
	case protoreflect.DoubleKind:
		g.generateAdder("Float64", keyName, varName, repeated)
	case protoreflect.BoolKind:
		g.generateAdder("Bool", keyName, varName, repeated)
	case protoreflect.StringKind:
		g.generateAdder("String", keyName, varName, repeated)
	case protoreflect.BytesKind:
		g.generateAdder("ByteString", keyName, varName, repeated)
	case protoreflect.EnumKind:
		if repeated {
			g.P(`ae.AppendString(`, varName, `.String())`)
		} else {
			g.P(`oe.AddString(`, keyName, `, `, varName, `.String())`)
		}
	case protoreflect.MessageKind:
		g.generateForMessageField(field, keyName, varName, repeated)
	case protoreflect.GroupKind:
		g.P(`// unsupported group type`)
	default:
		g.P(`// unsupported type: `, field.Desc.Kind())
	}
}

func (g *generator) generateForMessageField(
	field *protogen.Field,
	keyName, varName string,
	repeated bool,
) {
	// Special cases: well-known types.
	switch field.Message.Desc.FullName() {
	case "google.protobuf.Duration":
		g.P(`d := `, varName, `.AsDuration()`)
		g.generateAdder("Duration", keyName, "d", repeated)
		return
	case "google.protobuf.Timestamp":
		g.P(`t := `, varName, `.AsTime()`)
		g.generateAdder("Time", keyName, "t", repeated)
		return
	}

	if field.Desc.IsMap() {
		valField := field.Desc.MapValue()
		// Avoid unexpected loop.
		if valField.IsMap() {
			g.P(`// unsupported map type: nested map`)
			return
		}
		g.P(`oe.AddObject(keyName, `, g.zapObjectMarshalerFunc, `(func(oe `, g.zapObjectEncoder, `) error {`)
		g.In()
		g.P(`for mk, mv := range `, varName, ` {`)
		g.In()
		g.P(`key := `, g.fmtSprint, `(mk)`)
		g.generateForField(&protogen.Field{
			Desc: valField,
			Message: &protogen.Message{
				Desc: valField.Message(),
			},
		}, "key", "mv", false)
		g.Out()
		g.P(`}`)
		g.P(`return nil`)
		g.Out()
		g.P(`}))`)
		return
	}

	// Best-effort: marshal the object if it's a marshaler.
	g.P(`if `, varName, ` != nil {`)
	g.In()
	g.P(`var vv interface{} = `, varName)
	g.P(`if marshaler, ok := `, `vv.(`, g.zapObjectMarshaler, `); ok {`)
	g.In()
	g.generateAdder("Object", keyName, "marshaler", repeated)
	g.Out()
	g.P(`}`)
	g.Out()
	g.P(`}`)
}

func (g *generator) generateAdder(ftype, keyName, varName string, repeated bool) {
	if repeated {
		g.P("ae.Append", ftype, "(", varName, ")")
		return
	}
	g.P("oe.Add", ftype, "(", keyName, ", ", varName, ")")
}

func getOneOf(field *protogen.Field) (*protogen.Oneof, bool) {
	return field.Oneof, field.Oneof != nil
}

// GenerateFile zap marshalers for the proto messages in file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File, conservative bool) {
	g := newGenerator(gen, file, conservative)
	for _, msg := range file.Messages {
		g.generateForMessage(msg)
	}
}

func isTarget(opts protoreflect.ProtoMessage) bool {
	if opts == nil {
		return false
	}
	dp, ok := opts.(*descriptorpb.FieldOptions)
	if !ok {
		return false
	}
	return dp.ProtoReflect().Get(log.E_Include.TypeDescriptor()).Bool()
}
